<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<head>
    <th:block th:replace="~{fragments/head :: head}"></th:block>

    <!-- SPECIFIC CSS -->
    <link href="/css/blog.css" rel="stylesheet">

</head>

<body class="margin_sticky">

<header th:replace="~{fragments/subHeader :: subHeader}"></header>
<!-- /header -->

<main>
    <div class="page_header element_to_stick">
        <div class="container">
            <div class="row">
                <div class="col-xl-8 col-lg-7 col-md-7 d-none d-md-block">
                    <div class="breadcrumbs blog">
                        <ul>
                            <li><a href="#">Home</a></li>
                            <li><a href="#">Category</a></li>
                            <li>Page active</li>
                        </ul>
                    </div>
                </div>
                <div class="col-xl-4 col-lg-5 col-md-5">
                    <div class="search_bar_list">
                        <input type="text" class="form-control" placeholder="Search in blog...">
                        <input type="submit" value="Search">
                    </div>
                </div>
            </div>
            <!-- /row -->
        </div>
    </div>
    <!-- /page_header -->

    <div class="container margin_30_40">
        <div class="row">
            <div class="col-lg-9">
                <div class="singlepost">
                    <h1><span th:text="${board.title}"></span></h1>
                    <div class="postmeta">
                        <ul>
                            <li><a th:href="@{/board/{communityType}/list(communityType=${board.communityType})}"><i class="icon_folder-alt"></i><span
                                    th:text="${board.communityType}">카테고리</span></a></li>
                            <li><i class="icon_calendar"></i> <span
                                    th:text="${#temporals.format(board.createdAt, 'yyyy.MM.dd')}">2023.01.01</span></li>
                            <li><a href="#"><i class="icon_pencil-edit"></i><span th:text="${board.userName}"></span></a></li>
                            <li><a href="#"><i class="icon_comment_alt"></i><span id="comments-count"></span></a></li>
                            <li><a href="#" id="likeButton"><i th:class="${board.isLike} ? 'icon_heart' : 'icon_heart_alt'"></i> <span id="likes-count" th:text="${board.likesCount}"></span> </a></li>
                        </ul>
                    </div>
                    <div class="post-content">
                        <div class="dropcaps">
                            <p th:utext="${board.content}">Aorem Ipsum is simply dummy text of the printing and
                                typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since
                                the 1500s, when an unknown printer took a galley of type and scrambled it to make a type
                                specimen book. It has survived not only five centuries, but also the leap into
                                electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s
                                with the release of Letraset sheets containing Lorem Ipsum passages, and more recently
                                with desktop publishing software like Aldus PageMaker including versions of Lorem
                                Ipsum.</p>
                        </div>
                    </div>
                    <form th:action="@{'/board/delete/' + ${board.boardId}}" method="post"
                          th:if="${#authentication.isAuthenticated() and #authentication.principal instanceof T(org.springframework.security.core.userdetails.UserDetails) and board.userId == #authentication.principal.user.id}">
                        <button type="submit" class="btn btn-sm btn-danger"
                                onclick="return confirm('정말로 이 게시글을 삭제하시겠습니까?');">게시글 삭제</button>
                    </form>
                </div>
                <div id="comments">
                    <h5>전체 댓글</h5>
                    <ul id="comments-list">
                    </ul>

                    <div id="comments-pagination" class="pagination_fg"></div>
                </div>
                <hr>

                <h5>댓글 남기기</h5>
                <div class="comment-form">
                    <div class="form-group">
        <textarea class="form-control" name="content" id="commentContent" rows="6"
                  placeholder="댓글을 입력해 주세요."></textarea>
                    </div>
                    <div class="form-group">
                        <button type="button" id="submitCommentBtn" class="btn_1 add_bottom_15">등록</button>
                    </div>
                </div>
            </div>
            <!-- /col -->
            <script th:inline="javascript">
                /*<![CDATA[*/

                // 게시글 ID는 Thymeleaf에서 JavaScript로 전달받아야 합니다.
                const boardId = /*[[${board.boardId}]]*/ null;

                // 현재 로그인한 사용자 ID (서버에서 주입)
                const currentLoggedInUserId = /*[[${#authentication.isAuthenticated() ? (#authentication.principal instanceof T(org.springframework.security.core.userdetails.UserDetails) ? #authentication.principal.user.id : null) : null}]]*/ null;
                console.log(currentLoggedInUserId)

                const commentsList = document.getElementById('comments-list');
                const commentsPagination = document.getElementById('comments-pagination');
                const commentsCount = document.getElementById('comments-count');
                const submitCommentBtn = document.getElementById('submitCommentBtn'); // 등록 버튼
                const commentContentInput = document.getElementById('commentContent');

                // 댓글 아이템 HTML을 생성하는 함수
                function createCommentItem(comment) {
                    const li = document.createElement('li');
                    let avatarSrc = comment.authorProfileImageUrl || '/img/avatar1.jpg'; // 프로필 이미지 없으면 기본 이미지
                    const date = new Date(comment.createdAt);
                    const formattedDate = `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;

                    let actionButtonsHtml = '';
                    // 'writer' 필드가 백엔드에서 해당 댓글의 작성자인지 여부를 나타낸다고 가정
                    if (comment.writer) {
                        actionButtonsHtml = `
            <span class="edit-delete-buttons ms-2">
            <a class="btn btn-sm btn-danger" role="button" onclick="deleteComment(${comment.id})">삭제</a>
            </span>
            `;
                    }

                    li.innerHTML = `
            <div class="avatar">
                <a href="#">
                    <img src="${avatarSrc}" alt="${comment.author}" class="comment-avatar">
                </a>
            </div>
            <div class="comment_right clearfix">
                <div class="comment_info">
                    <a href="#">${comment.author}</a><span>|</span>${formattedDate}${actionButtonsHtml}
                </div>
                <p>${comment.content}</p>
            </div>
            `;
                    return li;
                }

                // 페이지네이션 링크를 생성하는 함수
                function createPaginationLink(pageNumber, isActive, text) {
                    const link = document.createElement('a');
                    link.href = '#';
                    link.dataset.page = pageNumber;
                    link.innerHTML = text;
                    if (isActive) {
                        link.classList.add('active');
                    }
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const targetPage = parseInt(e.target.dataset.page);
                        fetchComments(boardId, targetPage);
                    });
                    return link;
                }

                // 댓글 목록 및 페이지네이션을 렌더링하는 공통 함수
                function renderCommentsAndPagination(payload) {
                    commentsList.innerHTML = '';
                    if (payload.comments && payload.comments.length > 0) {
                        commentsCount.innerText = `(${payload.totalComments})`;
                        payload.comments.forEach(comment => {
                            commentsList.appendChild(createCommentItem(comment));
                        });
                    } else {
                        commentsCount.innerText = '(0)';
                        commentsList.innerHTML = '<p>아직 댓글이 없습니다. 첫 댓글을 작성해 보세요!</p>';
                    }

                    commentsPagination.innerHTML = '';
                    if (payload.totalPage > 1) {
                        if (!payload.isFirst) {
                            commentsPagination.appendChild(createPaginationLink(payload.page - 1, false, '&laquo;')); // 이전 페이지
                        }
                        const startPage = payload.beginPage - 1;
                        const endPage = payload.endPage - 1;
                        for (let i = startPage; i <= endPage; i++) {
                            commentsPagination.appendChild(createPaginationLink(i + 1, i === (payload.page - 1), (i + 1).toString()));
                        }
                        if (!payload.isLast) {
                            commentsPagination.appendChild(createPaginationLink(payload.page + 1, false, '&raquo;')); // 다음 페이지
                        }
                    }
                }

                // 댓글 가져오기 함수
                async function fetchComments(boardId, page = 0) {
                    if (!boardId) {
                        console.error('Board ID is null. Cannot fetch comments.');
                        return;
                    }

                    try {
                        const response = await fetch(`/comments?boardId=${boardId}&page=${page}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        console.log("Fetched comments data:", data);
                        renderCommentsAndPagination(data.payload);
                    } catch (error) {
                        console.error('Failed to fetch comments:', error);
                        commentsList.innerHTML = '<p>댓글을 불러오는 데 실패했습니다.</p>';
                    }
                }

                // 댓글 등록 함수
                submitCommentBtn.addEventListener('click', async () => {
                    const content = commentContentInput.value.trim();

                    if (content === '') {
                        alert('댓글 내용을 입력해주세요.');
                        return;
                    }

                    if (currentLoggedInUserId === null) {
                        alert('댓글을 작성하려면 로그인해야 합니다.');
                        window.location.href = '/';
                        return;
                    }

                    if (!boardId) {
                        console.error('Board ID is null. Cannot register comment.');
                        alert('게시글 정보를 찾을 수 없습니다.');
                        return;
                    }

                    try {
                        const formData = new URLSearchParams();
                        formData.append('boardId', boardId);
                        formData.append('content', content);

                        const headers = {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        };

                        const response = await fetch('/comments/regist', {
                            method: 'POST',
                            headers: headers,
                            body: formData.toString()
                        });

                        if (response.ok) {
                            const data = await response.json();
                            alert(data.message);
                            commentContentInput.value = '';
                            renderCommentsAndPagination(data.payload); // 댓글 등록 후 바로 렌더링
                        } else {
                            const errorData = await response.json();
                            alert(`댓글 등록 실패: ${errorData.message || response.statusText}`);
                        }
                    } catch (error) {
                        console.error('Failed to register comment:', error);
                        alert('댓글 등록 중 오류가 발생했습니다.');
                    }
                });

                // 삭제 버튼 클릭 시 실행될 함수
                function deleteComment(commentId) {
                    if (confirm('정말로 이 댓글을 삭제하시겠습니까?')) {
                        if (!boardId) {
                            console.error('Board ID is null. Cannot delete comment.');
                            alert('게시글 정보를 찾을 수 없어 댓글을 삭제할 수 없습니다.');
                            return;
                        }

                        // URLSearchParams를 사용하여 body에 boardId 추가
                        const formData = new URLSearchParams();
                        formData.append('boardId', boardId);

                        fetch(`/comments/${commentId}`, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded', // form-urlencoded 타입으로 변경
                                // CSRF 토큰이 필요하다면 여기에 추가
                            },
                            body: formData.toString()
                        })
                            .then(response => {
                                if (response.ok) {
                                    return response.json(); // 삭제 성공 시 응답 본문을 JSON으로 파싱
                                }
                                throw new Error('댓글 삭제에 실패했습니다.');
                            })
                            .then(data => {
                                alert('댓글이 삭제되었습니다.');
                                renderCommentsAndPagination(data.payload); // 삭제 후 바로 렌더링
                            })
                            .catch(error => {
                                console.error('댓글 삭제 중 오류 발생:', error);
                                alert(`댓글 삭제 중 오류가 발생했습니다: ${error.message}`);
                            });
                    }
                }

                // 페이지 로드 시 댓글 가져오기
                document.addEventListener('DOMContentLoaded', () => {
                    if (boardId) {
                        fetchComments(boardId, 0); // 첫 페이지(0) 로드
                    } else {
                        console.error("Board ID not found for fetching comments.");
                    }
                });

                const likeButton = document.getElementById('likeButton');
                const likeIcon = likeButton.querySelector('i');
                const likesCountSpan = document.getElementById('likes-count');

                likeButton.addEventListener('click', function(event) {
                    event.preventDefault(); // 기본 링크 동작 방지

                    fetch(`/board/like/${boardId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    })
                        .then(response => {
                            if (!response.ok) {
                                if (response.status === 401) {
                                    alert('로그인이 필요합니다.');
                                    window.location.href = '/';
                                } else if (response.status === 404) {
                                    alert('게시글을 찾을 수 없습니다.');
                                } else {
                                    alert('좋아요 처리 중 오류가 발생했습니다.');
                                }
                                throw new Error('Network response was not ok');
                            }
                            return response.json();
                        })
                        .then(data => {
                            alert(data.message);
                            if (data.payload.liked) {
                                likeIcon.classList.remove('icon_heart_alt');
                                likeIcon.classList.add('icon_heart');
                            } else {
                                likeIcon.classList.remove('icon_heart');
                                likeIcon.classList.add('icon_heart_alt');
                            }
                            likesCountSpan.textContent = data.payload.totalLikes;
                        })
                        .catch(error => {
                            console.error('Fetch error:', error);
                        });
                });

                /*]]>*/
            </script>

            <!-- 최근 본 게시글 위젯 JavaScript -->
            <th:block th:replace="~{fragments/boardSidebar :: recentBoardsScript}"></th:block>

            <th:block th:replace="~{fragments/boardSidebar :: boardSidebar}"></th:block>
            <!-- /aside -->
        </div>
        <!-- /row -->
    </div>
    <!-- /container -->

</main>
<!-- /main -->

<footer th:replace="~{fragments/footer :: footer}"></footer>
<!--/footer-->

<div id="toTop"></div><!-- Back to top button -->

<div class="layer"></div><!-- Opacity Mask Menu Mobile -->

<!-- COMMON SCRIPTS -->
<script src="/js/common_scripts.min.js"></script>
<script src="/js/common_func.js"></script>
<script src="/assets/validate.js"></script>

</body>
</html>